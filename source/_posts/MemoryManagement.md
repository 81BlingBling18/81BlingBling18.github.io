---
title: MemoryManagement
date: 2017-07-07 00:00:00
tags:
- Operation System
categories: 
- Operation System
---

操作系统内存管理总结
<!--more-->

# MemoryManagement

---

## base register + limit register

​    每个cpu设计一对base register 和limit register。当程序被加载进内存时，base register记录程序所占内存的起始地址，limit register记录程序所占内存的长度。当需要访问物理内存时，偏移地址+base register中的内容就是实际的物理地址。当然还要用limit register中的内容来检查偏移地址是不是越界了。

## swapping

​    如果一个程序在一段时间内不活动的话，就可以将其从内存中移动到磁盘中。另一种策略是只把需要的那部分程序加载到内存中，如果当前运行不需要一部分程序，那么就不将这部分程序加载到内存中。当程序再次活动时，再将其从磁盘中加载到内存中。考虑到程序在运行过程中可能会动态申请内存，因此在第一次加载程序到内存中时，就可以多分配一些内存，用于堆栈等等使用。在将程序移动到磁盘中时，多分配的这部分中，没有使用的内存就可以不移动到磁盘中。

​    当从磁盘中重新加载程序时，也要考虑到base register 和 limit register的改变。

## 空闲内存管理

### Bitmaps

​    用内存中的一位来表示一个字节是否被使用（0,未使用，1,已使用）。比方说32位内存中，一位表示一个字节的使用情况，那么一个字节可以表示32个字节的使用情况，也就是说bitmaps要占用内存的1/32。

​    当一个字节表示的内存单元越大，bitmaps占用的内存就越小，这时候对内存的管理也就越”粗糙“，在大多数情况下一个程序不能完全用完给它分配的内存。内存单元越小，bitmaps占用的内存越大，这时候对内存的管理越“精细”，这时候内存浪费也就越少。

### LinkedList

​    将物理内存按照顺序建立链表。比如程序A占用了一段内存a，那么创建一个节点，记录a已经被程序A占用，还要记录它的起始地址和占用内存的大小。接着这个程序A的是一块没有使用的内存空间b，那么再创建一个节点，记录内存b没有使用，起始地址就是a的结束地址，以及它的长度，如果b后面还有程序B的话，参考程序A的规则创建节点。

​    下面是寻找适合的内存块的几种方法：

- best fit：空闲内存按照从小到大的顺序排列，每次都找到能容纳下的最小内存区域，然后将所需的内存空间划分出来，剩下的内存空间重新插入到空闲内存队列中。这样的话每次产生的碎片都是最小的，缺点是产生大量极小的碎片，这些碎片往往难以再利用。
- worst fit：将空闲内存按照从大到小的顺序排列，每次找到能容纳下的最大内存区域，然后将所需内存空间划分出来，剩下的内存空间重新插入到空闲内存队列中。这种分配内存的方法，由于每次切分的都是最大的内存，剩余部分往往还能继续分配，因此产生的内存碎片数量比较少，但是需要大内存时有可能没有足够的内存空间分配。
- first fit：将空闲内存按照物理地址的顺序从大到小排列，从中选出第一个符合要求的空闲内存并进行划分。
- next fit：从上一个分配内存的节点开始寻找，而不是每次都从链表头开始寻找。
- quick fit：系统保持对常用内存大小的引用，比方说4k，8k，16k，每次程序申请内存时，从这些内存中进行分配。 

